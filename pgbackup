#!/bin/bash -e

# Perform an ascii backup of a single PostgreSQL database

# Constant values
set -u
SRC=${0%/*}
source $SRC/pitr/defaults

DB=$1
BACKUP="${DB}-$(date +'%Y%m%d-%H%M%S')-$(hostname)"
PGUSER=postgres

# Check to make sure the db is specified
if [ "$DB" = "" ]; then
    echo "Please specify which database you want to backup"
    echo "Example usage: root# pgbackup ntdi"
    exit 1
fi

# Check to make sure the backup dir exists
if [ ! -d $ARCHIVE ]; then
    if ! mkdir -p $ARCHIVE; then
        echo "ERROR: Unable to create: $ARCHIVE"
        exit 1
    fi
fi

# Change into the backups directory
if ! cd $ARCHIVE; then
    echo "Unable to cd into $ARCHIVE"
    exit 1
fi

# Create a temporary working directory and cd into it
tmpdir="processing-backup.$$"
if ! mkdir $tmpdir; then
    echo "Unable to create $ARCHIVE/$tmpdir"
    exit 1
else
    cd $tmpdir
fi

# Perform the backup
if ! $(pg_dump -U $PGUSER $DB > $BACKUP.sql); then
    echo "ERROR: Unable to create $BACKUP.sql"
    exit 1
fi

# Generate MD5 of the backup
echo "# MD5 HASH" > $BACKUP.DIGESTS
if ! md5sum $BACKUP.sql >> $BACKUP.DIGESTS; then
    echo "ERROR: Unable to create $BACKUP.DIGESTS"
    exit 1
fi

# Generate SHA1 hash of the backup
echo "# SHA1 HASH" >> $BACKUP.DIGESTS
if ! sha1sum $BACKUP.sql >> $BACKUP.DIGESTS; then
    echo "ERROR: Unable to create $BACKUP.sql"
    exit 1
fi

# Supported db configurations (aka where distros put stuff)
dirs="
    /etc/conf.d
    /etc/postgresql/8.0/main
    /etc/postgresql/8.1/main
    /etc/postgresql/8.3/main
    /etc/postgresql/8.4/main
    /var/lib/postgresql/data
    /var/log/postgresql
"
patterns="
    *.conf
    *.log
    postgresql
"

# Attempt to backup the database configuration
for dir in $dirs; do
    if [ -d $dir ]; then
        for pattern in $patterns; do
            for file in $(find $dir -type f -name $pattern); do
                if [ -r $file ]; then
                    copydir=$(dirname $file)
                    mkdir -p .$copydir
                    cp $file .$copydir/
                else
                    echo "Unable to read from (thus backup): $file"
                fi
            done
        done
    fi
done

# Fetch data about db required for restoration
info=$(psql -U $PGUSER -A -l | grep $DB | sed -e 's/|/,/g')
owner=$(echo $info | cut -d, -f2)
encoding=$(echo $info | cut -d, -f3)

# Create a readme
cat <<EOT >> README
Backup of $DB created: $(date)
To restore from this backup, you'd do something like:

# Become the postgres user (or whoever owns the db installation)
user# sudo su - $PGUSER

# This backup does not contain the required users for this db, so you
# will need to create them before you restore.  Probably something
# like the following, where you'd need to know the desired password:
postgres# createuser -P $owner

postgres# createdb -O $owner -E $encoding $DB
postgres# psql -c -t --quiet $DB < $BACKUP.sql

Please note you might need to restore OS type configuration as well.
Any config files that were saved as part of the backup appear in this
backup, with the file system structure mirrored.

Good luck!
EOT

# Create a tarbal of the backup artifacts
if ! tar -zcpf $BACKUP.tar.gz *; then
    echo "ERROR: Unable to create $BACKUP.tar.gz"
    exit 1
fi

# Move the tarball up into the archive
if ! mv $BACKUP.tar.gz ..; then
    echo "ERROR: Unable to move the tarball into $ARCHIVE"
    exit 1
fi

# Move back to the archive directory
if ! cd $ARCHIVE; then
    echo "ERROR: Unable to cd to $ARCHIVE"
    exit 1
fi

# Delete the temporary working directory
if ! rm -rf $ARCHIVE/$tmpdir; then
    echo "ERROR: Unable to delete $ARCHIVE/$tmpdir"
    exit 1
fi

# All is well
exit 0

